import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

def getBackupFilename() {
	def formattedDate = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"))
	def fileName = "postgres-backup-${formattedDate}.sql"

	echo "Created backup file name: ${fileName}"
	return fileName
}

pipeline {
	agent {
		kubernetes {
			inheritFrom 'default'
			defaultContainer 'buildpack'
		}
	}

	options {
		timeout(time: 45, unit: 'MINUTES')
		buildDiscarder(logRotator(numToKeepStr: '5'))
	}

	parameters {
		string(name: 'HELM_VERSION', defaultValue: params.HELM_VERSION ?: '0.0.1', description: 'Helm version', trim: true)
		booleanParam(name: 'CONFIRM_MIGRATION', defaultValue: false, description: 'Confirm PostgreSQL major version migration (will cause downtime)')
	}

	environment {
		K8S_GITHUB_URL = 'https://github.com/maxmorhardt/k8s'
		JOBS_GITHUB_URL = 'https://github.com/maxmorhardt/jenkins-jobs'

		DOCKER_REGISTRY = 'docker.io'
		DOCKER_REGISTRY_FULL = "oci://${env.DOCKER_REGISTRY}"

		APP_NAME = "db"
		NAMESPACE = "maxstash-global"
		POD_NAME = "${APP_NAME}-postgresql-0"
		BRANCH_NAME = 'main'
		
		KUBECONFIG = credentials('kube-config')
		POSTGRES = credentials('postgres')
	}

	stages {
		stage('Confirm Migration') {
			steps {
				script {
					if (!params.CONFIRM_MIGRATION) {
						error('Migration not confirmed. Check CONFIRM_MIGRATION parameter to proceed')
					}

					echo "PostgreSQL Major Version Migration"
				}
			}
		}

		stage('Setup') {
			steps {
				script {
					checkout scmGit(
						branches: [[
							name: "$BRANCH_NAME"
						]],
						userRemoteConfigs: [[
							credentialsId: 'github',
							url: "$K8S_GITHUB_URL"
						]]
					)

					checkout scmGit(
						branches: [[
							name: "$BRANCH_NAME"
						]],
						userRemoteConfigs: [[
							credentialsId: 'github',
							url: "$JOBS_GITHUB_URL"
						]]
					)

					sh 'ls -lah'
					echo "APP_NAME: $APP_NAME"
					echo "NAMESPACE: $NAMESPACE"
					echo "BRANCH: $BRANCH_NAME"
					echo "HELM_VERSION: $HELM_VERSION"
					sh 'exit 1'
				}
			}
		}

		stage('Backup Database') {
			steps {
				script {
					env.BACKUP_FILE = getBackupFilename()

					sh """
						kubectl exec ${POD_NAME} -n ${NAMESPACE} -c postgresql -- bash -c 'PGPASSWORD=${POSTGRES_PSW} pg_dumpall -U ${POSTGRES_USR} > /tmp/backup.sql'
						kubectl cp ${NAMESPACE}/${POD_NAME}:/tmp/backup.sql ${BACKUP_FILE} -c postgresql
					"""

					archiveArtifacts artifacts: "$BACKUP_FILE", fingerprint: true
				}
			}
		}

		stage('Uninstall Legacy Postgres') {
			steps {
				script {
					sh "helm uninstall $APP_NAME -n $NAMESPACE"
				}
			}
		}

		stage('Delete Legacy Data') {
			steps {
				dir('postgres-migration') {
					script {
						sh """
							kubectl delete pvc data-${POD_NAME} -n $NAMESPACE
							kubectl delete pv postgres

							kubectl apply -f cleanup.yaml -n $NAMESPACE
							kubectl wait --for=condition=complete job/cleanup-postgres-data -n $NAMESPACE --timeout=300s
							kubectl delete job cleanup-postgres-data -n $NAMESPACE
						"""
					}
				}
			}
		}

		stage('Deploy New Postgres') {
			steps {
				dir('postgres') {
					script {
						sh """
							kubectl apply -f storage.yaml

							helm upgrade $APP_NAME $DOCKER_REGISTRY_FULL/bitnamicharts/postgresql \
								--install \
								--atomic \
								--debug \
								--history-max=3 \
								--namespace $NAMESPACE \
								--version $HELM_VERSION \
								--values values.yaml \
								--set primary.service.type=ClusterIP \
								--set primary.readinessProbe.enabled=false
						"""
						
						echo "Waiting for PostgreSQL pod to be ready for restore..."
						sh "kubectl wait --for=condition=ready pod/${POD_NAME} -n ${NAMESPACE} --timeout=300s"
					}
				}
			}
		}

		stage('Restore Database') {
			steps {
				dir('postgres') {
					script {
						echo "Restoring database (connections will be rejected during restore)"
						
						sh """
							kubectl cp ${BACKUP_FILE} ${NAMESPACE}/${POD_NAME}:/tmp/restore.sql -c postgresql
							kubectl exec ${POD_NAME} -n ${NAMESPACE} -c postgresql -- bash -c 'PGPASSWORD=${POSTGRES_PSW} psql -U ${POSTGRES_USR} -d postgres -f /tmp/restore.sql'
						"""
						
						echo "Database restored successfully"
					}
				}
			}
		}
		
		stage('Enable Connections') {
			steps {
				dir('postgres') {
					script {
						echo "Enabling readiness probes to allow connections"
						
						sh """
							helm upgrade $APP_NAME $DOCKER_REGISTRY_FULL/bitnamicharts/postgresql \
								--install \
								--atomic \
								--debug \
								--history-max=3 \
								--namespace $NAMESPACE \
								--version $HELM_VERSION \
								--values values.yaml
						"""
						
						echo "PostgreSQL is now ready to accept connections"
					}
				}
			}
		}
	}
}
